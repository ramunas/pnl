type lam
nametype v

fn lam : ([v]lam) => lam
fn var : v => lam
fn app : (lam,lam) => lam

fn subst : ([v]lam, lam) => lam

name x : v
name y : v

var `X : lam
var `Y : lam
var `Z : lam
var `W - y : lam

rw subst([x]var(x),`X) ==> `X
rw subst([y]var(x),`X) ==> var(x)
rw subst([x]app(`X, `Y), `Z) ==>
    app(subst([x]`X, `Z), subst([x]`Y, `Z))
rw subst([x]lam([x]`X), `Y) ==> lam([x]`X)
rw subst([x]lam([y]`X), `W) ==> lam([y]subst([x]`X, `W))

# beta-rule
rw app(lam([x]`X), `Y) ==> subst([x]`X, `Y)

name z : v
rewrite subst([z]var(z), var(y))

normalize subst([z]var(z), var(y))
normalize subst([x]lam([y]var(x)), app(var(y), var(y)))
normalize subst([x]lam([y]var(x)), app(var(z), var(z)))

name a : v
name b : v
name c : v
# normalize app(lam([x]var(x)),`X)

rewrite app(lam([a]lam([b]app(var(a), var(b)))), lam([c]var(c)))
rewrite subst(([x]lam([b]app((var(x), var(b)))), lam([c]var(c))))
rewrite lam([y]subst(([x]app((var(x), var(y))), lam([c]var(c)))))
rewrite lam([y]app((subst(([x]var(x), lam([c]var(c)))), subst(([x]var(y), lam([c]var(c)))))))
rewrite lam([y]app((lam([c]var(c)), subst(([x]var(y), lam([c]var(c)))))))
rewrite lam([y]app((lam([c]var(c)), subst(([x]var(y), lam([c]var(c)))))))
rewrite lam([y]app((lam([c]var(c)), var(y))))
rewrite lam([y]subst(([x]var(x), var(y))))

rewrite lam([y]var(y))

# this is really a proposition. Should have a general means
# checking propositions
normalizes app(lam([a]lam([b]app(var(a), var(b)))), lam([c]var(c)))
    to lam([y]var(y))

# normalizes to the above
#normalize app(lam([a]lam([b]app(var(a), var(b)))), lam([c]var(c)))
#normalize app(lam([a]lam([b]app(var(a), var(b)))), lam([c]var(a)))

# self application
# normalize app(lam([x]app(var(x),var(x))), lam([x]app(var(x),var(x))))

# syntax \$n . $t = lam([$n]$t)
# syntax $t1[$n3 := $t2] = subst([$n3]$t1, $t2)


# vim:ft=pnl:

